#!/bin/bash
### Pretty colours!
export PS1="\[\033[0;36m\]\h \[\033[0;37m\](\W) "

alias python="python3.4"
alias py="python3.4"
alias pip="pip3"
alias wget="curl -O"
alias gopi="gox -osarch=\"linux/arm\""
alias gos3="gox -osarch=\"linux/amd64\""
alias finder="open ."
alias :q=exit
# Git aliases
alias gs="git status"
alias gd="git diff"
alias gcm="git commit -m"
alias gl="git log"
alias gch="git checkout"
alias gb="git branch"

PATH="/Users/will/src/sdk/platform-tools:/usr/local/opt/openssl/bin:/usr/local/heroku/bin:/usr/local/bin:/Library/Frameworks/Python.framework/Versions/3.4/bin:${PATH}"
export PATH="/Users/will/Dropbox/golang/bin:$PATH"
export PATH="$HOME/.wills-bin:$PATH"
export GOPATH="/Users/will/Dropbox/golang"

export PROJECT_PATH="$HOME/projects"
export GIT_REMOTES="gh|git@github.com:;ghp|https://github.com/;gl|git@gitlab.com:;eng|git@eng-git.canterbury.ac.nz:"

function db {
	if [ "$1" = "mysql" ]
	then
	  mysql.server $2
	else
	  if [ "$1" = "pg" ]
    then
      if [ "$2" = "start" ]
      then
        pg_ctl -D /usr/local/var/postgres -l /usr/local/var/postgres/server.log start
      else
        pg_ctl -D /usr/local/var/postgres stop -s -m fast
      fi
    fi
	fi
}

# "gcd" command


# Expected env variables:
# PROJECT_PATH (Path for things to go into)
# GIT_REMOTES (List of places to try and clone from)
# Should have one argument, in format:
# host_shortname/username/project
# project (Will only change to an existing project)

# Exit statuses:
# 1: config error
# 2: argument error
# 3: missing project
# ?: something else

function gcd() {

function split_to_arr() {
  input=$1
  delimiter=$2
  output=$3

  IFS="$delimiter" read -ra $output <<< "$input"
}

function split_to_vars() {
  split_to_arr "$1" "$2" list
  # This is easier than a loop
  if [ ! -z "$3" ]; then eval "$3=${list[0]}"; fi
  if [ ! -z "$4" ]; then eval "$4=${list[1]}"; fi
  if [ ! -z "$5" ]; then eval "$5=${list[2]}"; fi
  if [ ! -z "$6" ]; then eval "$6=${list[3]}"; fi
}

function echo_cd() {
  echo cd $@
  cd $@
}

if [ -z "$GIT_REMOTES" ]; then
  echo "GIT_REMOTES not set"
  return 1
fi

if [ -z "$1" ]; then
  echo "You need to give me a project or something"
  echo "  gcd <project name>"
  echo "  gcd <remote>/<username>/<project>"
  echo "GIT_REMOTES: $GIT_REMOTES"
  echo "PROJECT_PATH: $PROJECT_PATH"
  return 2
fi

split_to_vars "$1" "/" remote user project

if [ -z "$user$project" ]; then
  # Only project name given
  matching=$(find $PROJECT_PATH -maxdepth 3 -mindepth 3 -name "$remote*")
  if [ -z "$matching" ]; then
    echo "No existing projects named '$remote' in $PROJECT_PATH"
    return 3
  fi
  echo_cd "$matching"
  return
fi

path="$PROJECT_PATH/$remote/$user/$project" 
if [ -d "$path" ]; then
  echo_cd $path
  return
fi

split_to_arr "$GIT_REMOTES" ";" remote_list
for rem in ${remote_list[@]}; do
  split_to_vars "$rem" "|" short full
  if [ -z "$short" ] || [ -z "$full" ]; then
    echo "Invalid remote in GIT_REMOTES: $rem"
    return 1
  fi
  if [ "$short" = "$remote" ]; then
    full_remote="$full"
  fi
done

if [ -z "$full_remote" ]; then
  echo "Invalid remote ($remote) given"
  echo "GIT_REMOTES: $GIT_REMOTES"
  return 1
fi

if git clone "$full_remote$user/$project.git" "$path"; then
  echo_cd $path
fi
}
